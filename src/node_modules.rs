use crate::prelude::*;



#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Export {
    pub default : String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageJson {
    pub name : String,
    pub exports : Option<HashMap<String, Export>>,
    pub dependencies : Option<HashMap<String, String>>,
    pub files : Option<Vec<String>>,
    pub module : Option<String>,
    pub main : Option<String>,
}


pub struct NodeModule {
    pub folder : PathBuf,
    pub absolute : PathBuf,
    pub name : String,
    pub exports : HashMap<String, Module>,
    pub files : Vec<Module>,
}

impl NodeModule {
    pub async fn load<P>(absolute: P, package_json: PackageJson) -> Result<NodeModule> 
    where P: AsRef<Path> {

        // let files = Vec::new();
        let absolute = absolute.as_ref();
        let folder = absolute.parent().unwrap();

        let exports = if let Some(node_module_exports) = package_json.exports {
            let mut exports = HashMap::new();
            for (file, export) in node_module_exports.iter() {
                let path = folder.join(&export.default).canonicalize().await?;
                let module = Module::load(folder, &path).await?;
                exports.insert(file.to_string(), module);
            }
            exports
        } else {
            HashMap::new()
        };

        let filter = Filter::new(&["*.{js,mjs}"]);
        let mut relative_files = if let Some(files) = package_json.files {

            let globs = files
                .iter()
                .map(|s|s.as_str())
                .collect::<Vec<_>>();
            // globs.push("*.js");
            // println!("globs: {:#?}", globs);
            let aggregator = Filter::new(&globs);
            let list = get_files(&folder, Some(&aggregator),Some(&filter)).await?;
            // println!("{:#?}",list);
            list
        } else {
            let aggregator = Filter::new(&["*.{js,mjs}"]);
            get_files(&folder, Some(&aggregator),None).await?
        };

        if let Some(module) = &package_json.module {
            let path = folder.join(Path::new(module)).canonicalize().await?;
            relative_files.push(path.strip_prefix(folder).unwrap().to_path_buf());
        } else if let Some(module) = &package_json.main {
            if !module.is_empty() {
                let path = folder.join(Path::new(module)).canonicalize().await?;
                relative_files.push(path.strip_prefix(folder).unwrap().to_path_buf());
            }
        }

        let mut files = Vec::new();
        for relative in relative_files.iter() {
            files.push(Module::load(folder,relative).await?);
        } 

        let node_module = NodeModule {
            folder : folder.to_path_buf(),
            absolute : absolute.to_path_buf(),
            name : package_json.name.clone(),
            exports,
            files,
        };

        Ok(node_module)
    }
}

pub struct NodeModules {
    pub modules : Vec<Arc<NodeModule>>,
    pub modules_by_name : HashMap<String, Arc<NodeModule>>,
    pub modules_by_absolute : HashMap<PathBuf, Arc<NodeModule>>,
    // pub modules_by_ : HashMap<String, NodeModule>,
}

// pub async fn load_node_modules(ctx: &Context) -> Result<HashMap<String,Arc<NodeModule>>> {
pub async fn load_node_modules(ctx: &Context) -> Result<NodeModules> {

    let node_modules = &ctx.node_modules;

    let list = WalkDir::new(&node_modules)
        .into_iter()
        .flatten()
        .filter_map(|entry|{
            let path = entry.path();

            let file_name = path.file_name().unwrap().to_str().unwrap();
            if file_name == "package.json" {
                Some(path.to_path_buf())
            } else {
                None
            }
        });

    let mut modules = Vec::new();
    for absolute in list {
        // println!("`{}`", absolute.display());
        let text = std::fs::read_to_string(&absolute)?;
        let package_json: PackageJson = serde_json::from_str(&text)?;
        let node_module = NodeModule::load(&absolute, package_json).await?;
        // println!("{} files", node_module.files.len());
        modules.push(Arc::new(node_module));
    }

    let mut modules_by_name = HashMap::new();
    let mut modules_by_absolute = HashMap::new();
    for module in modules.iter() {
        modules_by_name.insert(module.name.clone(), module.clone());
        modules_by_absolute.insert(module.absolute.clone(), module.clone());
    }
    let node_modules = NodeModules {
        modules,
        modules_by_name,
        modules_by_absolute,
    };

    Ok(node_modules)

}