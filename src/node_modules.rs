use crate::prelude::*;



#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Export {
    pub default : String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageJson {
    pub name : String,
    pub exports : Option<HashMap<String, Export>>,
    pub dependencies : Option<HashMap<String, String>>,
    pub files : Option<Vec<String>>,
}


pub struct NodeModule {
    pub folder : PathBuf,
    pub name : String,
    pub exports : HashMap<String, Module>,
    pub files : Vec<Module>,
}

impl NodeModule {
    pub async fn load<P>(absolute: P, package_json: PackageJson) -> Result<NodeModule> 
    where P: AsRef<Path> {

        // let files = Vec::new();
        let folder = absolute.as_ref().parent().unwrap();

        let exports = if let Some(node_module_exports) = package_json.exports {
            let mut exports = HashMap::new();
            for (file, export) in node_module_exports.iter() {
                let path = folder.join(&export.default).canonicalize().await?;
                let module = Module::load(folder, &path).await?;
                exports.insert(file.to_string(), module);
            }
            exports
        } else {
            HashMap::new()
        };

        let filter = Filter::new(&["*.js"]);
        let relative_files = if let Some(files) = package_json.files {

            let globs = files
                .iter()
                .map(|s|s.as_str())
                .collect::<Vec<_>>();
            // globs.push("*.js");
            // println!("globs: {:#?}", globs);
            let aggregator = Filter::new(&globs);
            let list = get_files(&folder, Some(&aggregator),Some(&filter)).await?;
            // println!("{:#?}",list);
            list
        } else {
            let aggregator = Filter::new(&["*.js"]);
            get_files(&folder, Some(&aggregator),None).await?
        };

        let mut files = Vec::new();
        for relative in relative_files.iter() {
            files.push(Module::load(folder,relative).await?);
        } 

        let node_module = NodeModule {
            folder : folder.to_path_buf(),
            name : package_json.name.clone(),
            exports,
            files,
        };

        Ok(node_module)
    }
}

// pub struct NodeModules {
//     pub modules : HashMap<String, NodeModule>
// }

pub async fn load_node_modules(ctx: &Context) -> Result<HashMap<String,Arc<NodeModule>>> {

    let node_modules = &ctx.node_modules;

    let list = WalkDir::new(&node_modules)
        .into_iter()
        .flatten()
        .filter_map(|entry|{
            let path = entry.path();

            let file_name = path.file_name().unwrap().to_str().unwrap();
            if file_name == "package.json" {
                Some(path.to_path_buf())
            } else {
                None
            }
        });

    let mut module_list = Vec::new();
    for absolute in list {
        // println!("`{}`", absolute.display());
        let text = std::fs::read_to_string(&absolute)?;
        let package_json: PackageJson = serde_json::from_str(&text)?;
        let node_module = NodeModule::load(&absolute, package_json).await?;
        // println!("{} files", node_module.files.len());
        module_list.push(node_module);
    }

    let mut modules = HashMap::new();
    for module in module_list {
        modules.insert(module.name.clone(), Arc::new(module));
    }
    // let node_modules = NodeModules {
    //     modules
    // };

    Ok(modules)

}